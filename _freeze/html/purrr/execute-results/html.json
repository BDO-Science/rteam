{
  "hash": "cefa33f65e9e8a2a6ddb0087d578af3f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Apply functions with purrr :: Cheatsheet\"\ndescription: \" \"\nimage-alt: \"\"\nexecute:\n  eval: true\n  output: false\n  warning: true\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell .column-margin}\n<img src=\"images/logo-purrr.png\" height=\"138\" alt=\"Hex logo for purrr - a simple sketch of a sleeping cat nestled into the bottom of the black border of the hexagon. 'purrr' is written across the top in black.\" />\n<br><br><a href=\"../purrr.pdf\">\n<p><i class=\"bi bi-file-pdf\"></i> Download PDF</p>\n<img src=\"../pngs/purrr.png\" width=\"200\" alt=\"\"/>\n</a>\n<br><br><p>Translations (PDF)</p>\n* <a href=\"../translations/korean/purrr_ko.pdf\"><i class=\"bi bi-file-pdf\"></i>Korean</a>\n* <a href=\"../translations/portuguese/purrr_pt_br.pdf\"><i class=\"bi bi-file-pdf\"></i>Portuguese</a>\n* <a href=\"../translations/russian/purrr_ru.pdf\"><i class=\"bi bi-file-pdf\"></i>Russian</a>\n* <a href=\"../translations/spanish/purrr_es.pdf\"><i class=\"bi bi-file-pdf\"></i>Spanish</a>\n* <a href=\"../translations/ukrainian/purrr_uk.pdf\"><i class=\"bi bi-file-pdf\"></i>Ukrainian</a>\n* <a href=\"../translations/vietnamese/purrr_vi.pdf\"><i class=\"bi bi-file-pdf\"></i>Vietnamese</a>\n:::\n\n\n\npurrr enhances R's functional programming (FP) toolkit by providing a complete and consistent set of tools for working with functions and vectors.\nIf you've never heard of FP before, the best place to start is the family of [`map()`](https://purrr.tidyverse.org/reference/map.html) functions which allow you to replace many for loops with code that is both more succinct and easier to read.\nThe best place to learn about the [`map()`](https://purrr.tidyverse.org/reference/map.html) functions is the [iteration](https://r4ds.hadley.nz/iteration.html)[chapter](https://r4ds.had.co.nz/iteration.html) in R for Data Science.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\n```\n:::\n\n\n\n<!-- Page 1 -->\n\n## Map Functions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:10, b = 11:20, c = 21:30)\ny <- list(1, 2, 3)\nz <- list(4, 5, 6)\nl1 <- list(x = c(\"a\", \"b\"), y = c(\"c\", \"d\"))\nl2 <- list(x = \"a\", y = \"z\")\n```\n:::\n\n\n\n-   `map(.x, .f, ...)`: Apply a function to each element of a list of vector, and return a list.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map(l1, sort, decreasing = TRUE)\n    ```\n    :::\n\n\n\n-   `map2(.x, .y, .f, ...)`: Apply a function pairs of elements from two lists or vectors, return a list.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    map2(x, y, \\(x, y) x*y)\n    ```\n    :::\n\n\n\n    `imap(.x, .f, ...)` is shorthand for `map2(.x, names(.x), .f)` or `map2(.x, seq_along(.x), .f)` depending on whether `.x` is named or not.\n\n-   `pmap(.l, .f, ...)`: Apply a function to groups of elements from a list of lists or vectors, return a list.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pmap(list(x, y, z), function(first, second, third) first * (second + third))\n    ```\n    :::\n\n\n\n|           |                                                       | One list                            | Two lists                                            | Many lists                                                 |\n|-----------|-------------------------------------------------------|-------------------------------------|------------------------------------------------------|------------------------------------------------------------|\n| Logical   | Returns a logical vector.                             | `map_lgl(x, is.integer)`            | `` map2_lgl(l2, l1, `%in%`) ``                       | `` pmap_lgl(list(l2, l1), `%in%`) ``                       |\n| Integer   | Returns an integer vector.                            | `map_int(x, length)`                | `` map2_int(y, z, `+`) ``                            | `` pmap_int(list(y, z), `+`) ``                            |\n| Double    | Returns a double vector.                              | `map_dbl(x, mean)`                  | `map2_dbl(y, z, ~ .x / .y)`                          | `pmap_dbl(list(y, z), ~ .x / .y)`                          |\n| Character | Returns a character vector.                           | `map_chr(l1, paste, collapse = \"\")` | `map2_chr(l1, l2, paste, collapse = \",\", sep = \":\")` | `pmap_chr(list(l1, l2), paste, collapse = \",\", sep = \":\")` |\n| Vector    | Returns a vector that is of the simplest common type. | `map_vec(l1, paste, collapse = \"\")` | `map2_vec(l1, l2, paste, collapse = \",\", sep = \":\")` | `pmap_chr(list(l1, l2), paste, collapse = \",\", sep = \":\")` |\n| No output | Calls `.f` for its side-effect.                       | `walk(x, print)`                    | `walk2(objs, paths, save)`                           | `pwalk(list(objs, paths), save)`                           |\n\n### Function Shortcuts\n\n-   Use `\\(x)` with functions like `map()` that have single arguments.\n    `map(l, \\(x) x + 2)` becomes `map(l, function(x) x + 2)`.\n\n-   Use `\\(x, y)` with functions like `map2()` that have two arguments.\n    `map2(l, p, \\(x, y) x + y)` becomes `map2(l, p, function(l, p) l + p)`.\n\n-   Use `\\(x, y, z)` etc. with functions like `pmap()` that have many arguments.\n    `pmap(list(x, y, z), ⁠\\(x, y, z) x + y / z)` becomes `pmap(list(x, y, z), function(x, y, z) x * (y + z))`.\n\n-   Use `\\(x, y)` with functions like `imap()`.\n    `x` will get the list value and `y` with get the index, or name if available.\n    `imap(list(\"a\", \"b\", \"c\"), \\(x, y) paste0(y, \": \", x))` outputs `index: value` for each item.\n\n-   Use a `string` or `integer` with any map function to index list elements by name or position.\n    `map(l, \"name\")` becomes `map(l, function(x) x[[\"name\"]])`.\n\n### Modify\n\n-   `modify(.x, .f, ...)`: Apply a function to each element.\n    Also `modify2()` and `imodify()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify(x, ~ . + 2)\n    ```\n    :::\n\n\n\n-   `modify_at(.x, .at, .f, ...)`: Apply a function to selected elements.\n    Also `map_at()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_at(x, \"b\", ~ . + 2)\n    ```\n    :::\n\n\n\n-   `modify_if(.x, .p, .f, ...)`: Apply a function to elements that pass a test.\n    Also `map_if()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_if(x, is.numeric, ~ . + 2)\n    ```\n    :::\n\n\n\n-   `modify_depth(.x, .depth, .f, ...)`: Apply function to each element at a given level of a list.\n    Also `map_depth()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_depth(x, 1, ~ . + 2)\n    ```\n    :::\n\n\n\n### Reduce\n\n-   `reduce(.x, .f, ..., .init, .dir = c(\"forward\", \"backward\"))`: Apply function recursively to each element of a list of vector.\n    Also `reduce2()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- list(1, 2, 3, 4)\n    reduce(a, sum)\n    ```\n    :::\n\n\n\n-   `accumulate(.x, .f, ..., .init)`: Reduce a list, but also return intermediate results in a list.\n    Also `accumulate2()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- list(1, 2, 3, 4)\n    accumulate(a, sum)\n    ```\n    :::\n\n\n\n<!-- Page 2 -->\n\n## Vectors\n\n-   `compact(.x, .p = identity)`: Discard empty elements.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    compact(x)\n    ```\n    :::\n\n\n\n-   `keep_at()`: Keep/discard elements based by name or position.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    keep_at(x, \"a\")\n    keep_at(x, 2)\n    ```\n    :::\n\n\n\n-   `set_names(x, nm = x)`: Set the names of a vector/list directly or with a function.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    set_names(x, c(\"p\", \"q\", \"r\"))\n    set_names(x, tolower)\n    ```\n    :::\n\n\n\n### Predicate functions\n\nA predicate function returns a single `TRUE` or `FALSE` and purrr provides\n\n-   `keep(.x, .p, ...)` retains elements where the predicate is `TRUE`; `discard(.x, .p, ...)` drops elements where the predicate is `TRUE`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    keep(x, is.numeric)\n    discard(x, is.numeric)\n    ```\n    :::\n\n\n\n-   `head_while(.x, .p, ...)` keeps the first elements until one fails the predicate.\n    Also `tail_while()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    head_while(x, is.character)\n    ```\n    :::\n\n\n\n-   `detect(.x, .f, ..., dir = c(\"forward\", \"backward\"), .right = NULL)`: Find first element to pass.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    detect(x, is.character)\n    ```\n    :::\n\n\n\n-   `detect_index(.x, .f, ..., dir = c(\"forward\", \"backward\"), .right = NULL)`: Find index of first element to pass.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    detect_index(x, is.character)\n    ```\n    :::\n\n\n\n-   `every(.x, .p, ...)`: Do all elements pass a test?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    every(x, is.character)\n    ```\n    :::\n\n\n\n-   `some(.x, .p, ...)`: Do some elements pass a test?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    some(x, is.character)\n    ```\n    :::\n\n\n\n-   `none(.x, .p, ...)`: Do no elements pass a test?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    none(x, is.character)\n    ```\n    :::\n\n\n\n-   `has_element(.x, .y)`: Does a list contain an element?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    has_element(x, \"foo\")\n    ```\n    :::\n\n\n\n### Pluck\n\n-   `pluck(.x, ..., .deault = NULL)`: Select an element by name or index.\n    Also `attr_getter()` and `chuck()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pluck(x, \"b\")\n    x |> pluck(\"b\")\n    ```\n    :::\n\n\n\n-   `assign_in(x, where, value)`: Assign a value to a location using pluck selection.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    assign_in(x, \"b\", 5)\n    x |> assign_in(\"b\", 5)\n    ```\n    :::\n\n\n\n-   `modify_in(.x, .where,, .f)`: Apply a function to a value at a selected location.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    modify_in(x, \"b\", abs)\n    ```\n    :::\n\n\n\n### Reshape\n\n-   `list_flatten(x)`: Remove a level of indexes from a list.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list_flatten(x)\n    ```\n    :::\n\n\n\n-   `list_transpose(x)`: Transposes the index order in a multi-level list.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list_transpose(x)\n    ```\n    :::\n\n\n\n### Concatenate\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- list(a = 1, b = 2, c = 3)\nx2 <- list(\n  a = data.frame(x = 1:2),\n  b = data.frame(y = \"a\")\n)\n```\n:::\n\n\n\n-   `list_c()`: Combines elements into a vector by concatenating them together.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list_c(x1)\n    ```\n    :::\n\n\n\n-   `list_rbind()`: Combines elements into a data frame by row-binding them together.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list_rbind(x2)\n    ```\n    :::\n\n\n\n-   `list_cbind()`: Combines elements into a data frame by column-binding them together.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    list_cbind(x2)\n    ```\n    :::\n\n\n\n### List-Columns\n\n**List-columns** are columns of a data frame where each element is a list or vector instead of an atomic value.\nColumns can also be lists of data frames.\nSee **tidyr** for more about nested data and list columns.\n\n#### Work With List-Columns\n\nManipulate list-columns like any other kind of column, using **dplyr** functions like `mutate()` and `transmute()`.\nBecause each element is a list, use **map functions** within a column function to manipulate each element.\n\n-   `map()`, `map2()`, or `pmap()` return lists and will **create new list-columns**.\n    In this example, `transmute()` is a column function, `map2()` is a list function which returns a list, and `vehicles` and `starships` are list-columns.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dplyr::starwars |>\n      dplyr::mutate(ships = map2(vehicles, starships, append))\n    ```\n    :::\n\n\n\n-   Suffixed map functions like `map_int()` return an atomic data type and will **simplify list-columns into regular columns**.\n    In this example, `mutate()` is a column function, `map_int()` is a list function which returns a column vector, and `films` is a list column.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dplyr::starwars |>\n      dplyr::mutate(n_films = map_int(films, length))\n    ```\n    :::\n\n\n\n------------------------------------------------------------------------\n\nCC BY SA Posit Software, PBC • [info\\@posit.co](mailto:info@posit.co) • [posit.co](https://posit.co)\n\nLearn more at [purrr.tidyverse.org](https://purrr.tidyverse.org).\n\nUpdated: 2024-05.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"purrr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '1.0.2'\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}