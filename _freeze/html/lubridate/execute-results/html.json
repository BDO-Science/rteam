{
  "hash": "c96684669371dc2394925a346a059e92",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Dates and times with lubridate :: Cheatsheet\"\ndescription: \" \"\nimage-alt: \"\"\nexecute:\n  eval: true\n  output: false\n  warning: false\n---\n\n::: {.cell .column-margin}\n<img src=\"images/logo-lubridate.png\" height=\"138\" alt=\"Hex logo for lubridate - a white calendar on a green background, with a clock superimposed on it. 'lubdridate' is written in white across the bottom.\" />\n<br><br><a href=\"../lubridate.pdf\">\n<p><i class=\"bi bi-file-pdf\"></i> Download PDF</p>\n<img src=\"../pngs/lubridate.png\" width=\"200\" alt=\"\"/>\n</a>\n<br><br><p>Translations (PDF)</p>\n* <a href=\"../translations/portuguese/lubridate_pt_br.pdf\"><i class=\"bi bi-file-pdf\"></i>Portuguese</a>\n* <a href=\"../translations/russian/lubridate_ru.pdf\"><i class=\"bi bi-file-pdf\"></i>Russian</a>\n* <a href=\"../translations/spanish/lubridate_es.pdf\"><i class=\"bi bi-file-pdf\"></i>Spanish</a>\n* <a href=\"../translations/ukrainian/lubridate_uk.pdf\"><i class=\"bi bi-file-pdf\"></i>Ukrainian</a>\n* <a href=\"../translations/vietnamese/lubridate_vi.pdf\"><i class=\"bi bi-file-pdf\"></i>Vietnamese</a>\n:::\n\n\n\n## Date-times\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n:::\n\n\n\n\n\nA **date-time** is a point on the timeline, stored as the number of seconds since 1970-01-01 00:00:00 UTC\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- as_datetime(1511870400)\n```\n:::\n\n\n\nA **date** is a day stored as the number of days since 1970-01-01\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- as_date(17498)\n```\n:::\n\n\n\nAn hms is a **time** stored as the number of seconds since 00:00:00\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt <- hms::as_hms(85)\n```\n:::\n\n\n\n### Parse Date-Times\n\nConvert strings or numbers to date-times\n\n1.  Identify the order of the year (**y**), month (**m**), day (**d**), hour (**h**), minute (**m**) and second (**s**) elements in your data.\n\n2.  Use the function below whose name replicates the order.\n    Each accepts a `tz` argument to set the time zone, e.g. `ymd(x, tz = \"UTC\")`.\n\n-   `ymd_hms()`, `ymd_hm()`, `ymd_h()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ymd_hms(\"2017-11-28T14:02:00\")\n    ```\n    :::\n\n\n\n-   `ydm_hms()`, `ydm_hm()`, `ydm_h()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ydm_hms(\"2017-22-12 10:00:00\")\n    ```\n    :::\n\n\n\n-   `mdy_hms()`, `mdy_hm()`, `mdy_h()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mdy_hms(\"11/28/2017 1:02:03\")\n    ```\n    :::\n\n\n\n-   `dmy_hms()`, `dmy_hm()`, `dmy_h()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dmy_hms(\"1 Jan 2017 23:59:59\")\n    ```\n    :::\n\n\n\n-   `ymd()`, `ydm()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ymd(20170131)\n    ```\n    :::\n\n\n\n-   `mdy()`, `myd()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mdy(\"July 4th, 2000\")\n    ```\n    :::\n\n\n\n-   `dmy()`, `dym()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dmy(\"4th of July '99\")\n    ```\n    :::\n\n\n\n-   `yq()`: Q for quarter.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    yq(\"2001: Q3\")\n    ```\n    :::\n\n\n\n-   `my()`, `ym()`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    my(\"07-2020\")\n    ```\n    :::\n\n\n\n-   `hms::hms()`: Also `lubridate::hms()`, `hm()`, and `ms()`, which return periods\\*.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    hms::hms(seconds = 0, minutes = 1, hours = 2)\n    ```\n    :::\n\n\n\n-   `date_decimal(decimal, tz = \"UTC\")`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    date_decimal(2017.5)\n    ```\n    :::\n\n\n\n-   `now(tzone = \"\")`: Current time in tz (defaults to system tz).\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    now()\n    ```\n    :::\n\n\n\n-   `today(tzone = \"\")`: Current date in a tz (defaults to system tz).\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    today()\n    ```\n    :::\n\n\n\n-   `fast_strptime()`: Faster strptime.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    fast_strptime(\"9/1/01\", \"%y/%m/%d\")\n    ```\n    :::\n\n\n\n-   `parse_date_time()`: Easier strptime.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    parse_date_time(\"09-01-01\", \"ymd\")\n    ```\n    :::\n\n\n\n### Get and Set Components\n\nUse an accessor function to get a component.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-11-28\"\n```\n\n\n:::\n\n```{.r .cell-code}\nday(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28\n```\n\n\n:::\n:::\n\n\n\nAssign into an accessor function to change a component in place.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nday(d) <- 1\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2017-11-01\"\n```\n\n\n:::\n:::\n\n\n\n-   `date(x)`: Date component.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    date(dt)\n    ```\n    :::\n\n\n\n-   `year(x)`: Year.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    year(dt)\n    ```\n    :::\n\n\n\n-   `isoyear(x)`: The ISO 8601 year.\n\n-   `epiyear(x)`: Epidemiological year.\n\n-   `month(x, label, abbr)`: Month.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    month(dt)\n    ```\n    :::\n\n\n\n-   `day(x)`: Day of the month.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    day(dt)\n    ```\n    :::\n\n\n\n-   `wday(x, label, abbr)`: Day of week.\n\n-   `qday(x)`: Day of quarter.\n\n-   `hour(x)`: Hour.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    hour(dt)\n    ```\n    :::\n\n\n\n-   `minute(x)`: Minutes.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    minute(dt)\n    ```\n    :::\n\n\n\n-   `second(x)`: Seconds.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    second(dt)\n    ```\n    :::\n\n\n\n-   `tz(x)`: Time zone.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    tz(dt)\n    ```\n    :::\n\n\n\n-   `week(x)`: Week of the year.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    week(dt)\n    ```\n    :::\n\n\n\n-   `isoweek()`: ISO 8601 week.\n\n-   `epiweek()`: Epidemiological week.\n\n-   `quarter(x)`: Quarter.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    quarter(dt)\n    ```\n    :::\n\n\n\n-   `semester(x, with_year = FALSE)`: Semester.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    semester(dt)\n    ```\n    :::\n\n\n\n-   `am(x)`: Is it in the am?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    am(dt)\n    ```\n    :::\n\n\n\n-   `pm(x)`: Is it in the pm?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    pm(dt)\n    ```\n    :::\n\n\n\n-   `dst(x)`: Is it daylight savings?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dst(d)\n    ```\n    :::\n\n\n\n-   `leap_year(x)`: Is it a leap year?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    leap_year(d)\n    ```\n    :::\n\n\n\n-   `update(object, ..., simple = FALSE)`\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    update(dt, mday = 2, hour = 1)\n    ```\n    :::\n\n\n\n## Round Date-times\n\n-   `floor_date(x, unit = \"second\")`: Round down to nearest unit.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    floor_date(dt, unit = \"month\")\n    ```\n    :::\n\n\n\n-   `round_date(x, unit = \"second\")`: Round to nearest unit.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    round_date(dt, unit = \"month\")\n    ```\n    :::\n\n\n\n-   `ceiling_date(x, unit = \"second\")`: Round up to the nearest unit.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ceiling_date(dt, unit = \"month\")\n    ```\n    :::\n\n\n\nValid units are second, minute, hour, day, week, month, bimonth, quarter, season, halfyear and year.\n\n-   `rollback(dates, roll_to_first = FALSE, preserve_hms = TRUE)`: Roll back to last day of previous month.\n    Also `rollforward()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    rollback(dt)\n    ```\n    :::\n\n\n\n## Stamp Date-times\n\n`stamp()`: Derive a template from an example string and return a new function that will apply the template to date-times.\nAlso `stamp_date()` and `stamp_time()`.\n\n1.  Derive a template, create a function\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sf <- stamp(\"Created Sunday, Jan 17, 1999 3:34\")\n    ```\n    :::\n\n\n\n2.  Apply the template to dates\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    sf(ymd(\"2010-04-05\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Created Monday, Apr 05, 2010 00:00\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n**Tip: use a date with day \\> 12**\n\n## Time Zones\n\nR recognizes \\~600 time zones.\nEach encodes the time zone, Daylight Savings Time, and historical calendar variations for an area.\nR assigns *one* time zone per vector.\n\nUse the `UTC` time zone to avoid Daylight Savings.\n\n-   `OlsonNames()`: Returns a list of valid time zone names.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    OlsonNames()\n    ```\n    :::\n\n\n\n-   `Sys.timezone()`: Gets current time zone.\n\n-   `with_tz(time, tzone = \"\")`: Get the **same date-time** in a new time zone (a new clock time).\n    Also `local_time(dt, tz, units)`.\n    For example, 4:00 Pacific becomes 5:00 Mountain, or 6:00 Central, or 7:00 Eastern.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    with_tz(dt, \"US/Pacific\")\n    ```\n    :::\n\n\n\n-   `force_tz(time, tzone = \"\")`: Get the **same clock time** in a new time zone (a new date-time).\n    Also `force_tzs()`.\n    For example, 7:00 Pacific becomes 7:00 Mountain, or 7:00 Central, or 7:00 Eastern.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    force_tz(dt, \"US/Pacific\")\n    ```\n    :::\n\n\n\n## Math with Date-times\n\nLubridate provides three classes of timespans to facilitate math with dates and date-times.\n\nMath with date-times relies on the **timeline**, which behaves inconsistently.\nConsider how the timeline behaves during:\n\n-   A normal day:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnor <- ymd_hms(\"2018-01-01 01:30:00\", tz = \"US/Eastern\")\n```\n:::\n\n\n\n-   The start of daylight savings (spring forward):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngap <- ymd_hms(\"2018-03-11 01:30:00\", tz = \"US/Eastern\")\n```\n:::\n\n\n\n-   The end of daylight savings (fall back):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlap <- ymd_hms(\"2018-11-04 00:30:00\", tz = \"US/Eastern\")\n```\n:::\n\n\n\n-   Leap years and leap seconds:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleap <- ymd(\"2019-03-01\")\n```\n:::\n\n\n\n**Periods** track changes in clock times, which ignore time line irregularities.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnor + minutes(90)\ngap + minutes(90)\nlap + minutes(90)\nleap + years(1)\n```\n:::\n\n\n\n**Durations** track the passage of physical time, which deviates from clock time when irregularities occur.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnor + dminutes(90)\ngap + dminutes(90)\nlap + dminutes(90)\nleap + dyears(1)\n```\n:::\n\n\n\n**Intervals** represent specific intervals of the timeline, bounded by start and end date-times.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninterval(nor, nor + minutes(90))\ninterval(gap, gap + minutes(90))\ninterval(lap, lap + minutes(90))\ninterval(leap, leap + years(1))\n```\n:::\n\n\n\nNot all years are 365 days due to **leap days**.\nNot all minutes are 60 seconds due to **leap seconds**.\nIt is possible to create an imaginary date by adding **months**, e.g.\nFebruary 31st.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njan31 <- ymd(20180131)\njan31 + months(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n`%m+%` and `%m-%` will roll imaginary dates to the last day of the previous month.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njan31 %m+% months(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-02-28\"\n```\n\n\n:::\n:::\n\n\n\n`add_with_rollback(e1, e2, roll_to_first = TRUE)` will roll imaginary dates to the first day of the new month.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_with_rollback(jan31, months(1), roll_to_first = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2018-03-01\"\n```\n\n\n:::\n:::\n\n\n\n### Periods\n\nAdd or subtract periods to model events that happen at specific clock times, like the NYSE opening bell.\n\nMake a period with the name of a time unit **pluralized**, e.g.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- months(3) + days(12)\n\n# Shows the number of months, number of days, etc.\np\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3m 12d 0H 0M 0S\"\n```\n\n\n:::\n:::\n\n\n\n-   `years(x = 1)`: x years.\n\n-   `months(x = 1)`: x months.\n\n-   `weeks(x = 1)`: x weeks.\n\n-   `days(x = 1)`: x days.\n\n-   `hours(x = 1)`: x hours.\n\n-   `minutes(x = 1)`: x minutes.\n\n-   `seconds(x = 1)`: x seconds.\n\n-   `milliseconds(x = 1)`: x milliseconds.\n\n-   `microseconds(x = 1)`: x microseconds.\n\n-   `nanoseconds(x = 1)`: x nanoseconds.\n\n-   `picoseconds(x = 1)`: x picoseconds.\n\n-   `period(num = NULL, units = \"second\", ...)`: An automation friendly period constructor.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    period(5, unit = \"years\")\n    ```\n    :::\n\n\n\n-   `as.period(x, unit)`: Coerce a timespan to a period, optionally in the specified units.\n    Also `is.period()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    as.period(p)\n    ```\n    :::\n\n\n\n-   `period_to_seconds(x)`: Convert a period to the \"standard\" number of seconds implied by the period.\n    Also `seconds_to_period()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    period_to_seconds(p)\n    ```\n    :::\n\n\n\n### Durations\n\nAdd or subtract durations to model physical processes, like battery life.\nDurations are stored as seconds, the only time unit with a consistent length.\n**Difftimes** are a class of durations found in base R.\n\nMake a duration with the name of a period prefixed with a *d*, e.g.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndd <- ddays(14)\n\n# Shows the exact length in seconds, and the equivalent in common units\ndd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1209600s (~2 weeks)\"\n```\n\n\n:::\n:::\n\n\n\n-   `dyears(x = 1)`: 31536000x seconds.\n\n-   `dmonths(x = 1)`: 2629800x seconds.\n\n-   `dweeks(x = 1)`: 604800x seconds.\n\n-   `ddays(x = 1)`: 86400x seconds.\n\n-   `dhours(x = 1)`: 3600x seconds.\n\n-   `dminutes(x = 1)`: 60x seconds.\n\n-   `dseconds(x = 1)`: x seconds.\n\n-   `dmilliseconds(x = 1)`: x \\* 10^-3^ seconds.\n\n-   `dmicroseconds(x = 1)`: x \\* 10^-6^ seconds.\n\n-   `dnanoseconds(x = 1)`: x \\* 10^-9^ seconds.\n\n-   `dpicoseconds(x = 1)`: x \\* 10^-12^ seconds.\n\n-   `duration(num = NULL, units = \"second\", ...)`: An automation friendly duration constructor.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    duration(5, unit = \"years\")\n    ```\n    :::\n\n\n\n-   `as.duration(x, ...)`: Coerce a timespan to a duration.\n    Also `is.duration()`, `is.difftime()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    as.duration(p)\n    ```\n    :::\n\n\n\n-   `make_difftime(x)`: Make diffime with the specified number of units.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    make_difftime(99999)\n    ```\n    :::\n\n\n\n### Intervals\n\nDivide an interval by a duration to determine its physical length, divide by an interval by a period to determine its implied length in clock time.\n\nMake an interval with `interval()` or `%--%`, e.g.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- interval(ymd(\"2017-01-01\"), d)\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2017-01-01 UTC--2017-11-01 UTC\n```\n\n\n:::\n\n```{.r .cell-code}\n# Shows the exact length in seconds, and the equivalent in common units\nj <- d %--% ymd(\"2017-12-31\")\nj\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2017-11-01 UTC--2017-12-31 UTC\n```\n\n\n:::\n:::\n\n\n\n-   `a %within% b`: Does interval or dte0time `a` fall within interval `b`?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    now() %within% i\n    ```\n    :::\n\n\n\n-   `int_start(int)`: Access/set the start date-time of an interval.\n    Also `int_end()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    int_start(i) <- now()\n    int_start(i)\n    ```\n    :::\n\n\n\n-   `int_aligns(int1, int2)`: Do two intervals share a boundary?\n    Also `int_overlaps()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    int_aligns(i, j)\n    ```\n    :::\n\n\n\n-   `int_diff(times)`: Make the intervals that occur between the date-times in a vector.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    v <- c(dt, dt + 100, dt + 1000)\n    int_diff(v)\n    ```\n    :::\n\n\n\n-   `int_flip(int)`: Reverse the direction of an interval.\n    Also `int_standardize()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    int_flip(i)\n    ```\n    :::\n\n\n\n-   `int_length(int)`: Length in seconds.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    int_length(i)\n    ```\n    :::\n\n\n\n-   `int_shift(int, by)`: Shifts an interval up or down the timeline by a timespan.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    int_shift(i, days(-1))\n    ```\n    :::\n\n\n\n-   `as.interval(x, start, ...)`: Coerce a timespan to an interval with the start date-time.\n    Also `is.interval()`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    as.interval(days(-1), start = now())\n    ```\n    :::\n\n\n\n------------------------------------------------------------------------\n\nCC BY SA Posit Software, PBC • [info\\@posit.co](mailto:info@posit.co) • [posit.co](https://posit.co)\n\nLearn more at [lubridate.tidyverse.org](https://lubridate.tidyverse.org).\n\nUpdated: 2024-05.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"lubridate\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '1.9.3'\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}