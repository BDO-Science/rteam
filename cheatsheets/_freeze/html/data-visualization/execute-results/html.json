{
  "hash": "fc17e24ae60b552be45cc19ea6d5d8e9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data visualization with ggplot2 :: Cheat Sheet\"\ndescription: \" \"\nexecute:\n  eval: true\n  output: false\n  warning: false\n---\n\n::: {.cell .column-margin}\n<img src=\"images/logo-ggplot2.png\" height=\"138\" alt=\"Hex logo for ggplot2 - Six points following an overall increasing trend filled with colors going from light blue to dark blue, connected with a black line, on a light gray background with white grid lines.\" />\n<br><br><a href=\"../data-visualization.pdf\">\n<p><i class=\"bi bi-file-pdf\"></i> Download PDF</p>\n<img src=\"../pngs/data-visualization.png\" width=\"200\" alt=\"\"/>\n</a>\n<br><br><p>Translations (PDF)</p>\n* <a href=\"../translations/chinese/data-visualization_zh.pdf\"><i class=\"bi bi-file-pdf\"></i>Chinese</a>\n* <a href=\"../translations/dutch/data-visualization_nl.pdf\"><i class=\"bi bi-file-pdf\"></i>Dutch</a>\n* <a href=\"../translations/french/data-visualization_fr.pdf\"><i class=\"bi bi-file-pdf\"></i>French</a>\n* <a href=\"../translations/german/data-visualization_de.pdf\"><i class=\"bi bi-file-pdf\"></i>German</a>\n* <a href=\"../translations/japanese/data-visualization_ja.pdf\"><i class=\"bi bi-file-pdf\"></i>Japanese</a>\n* <a href=\"../translations/portuguese/data-visualization_pt.pdf\"><i class=\"bi bi-file-pdf\"></i>Portuguese</a>\n* <a href=\"../translations/spanish/data-visualization_es.pdf\"><i class=\"bi bi-file-pdf\"></i>Spanish</a>\n* <a href=\"../translations/turkish/data-visualization_tr.pdf\"><i class=\"bi bi-file-pdf\"></i>Turkish</a>\n* <a href=\"../translations/vietnamese/data-visualization_vi.pdf\"><i class=\"bi bi-file-pdf\"></i>Vietnamese</a>\n:::\n\n\n\n\n<!-- Page 1 -->\n\n## Basics\n\n**ggplot2** is based on the **grammar of graphics**, the idea that you can build every graph from the same components: a **data** set, a **coordinate system**, and **geoms**---visual marks that represent data points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n\n\nTo display values, map variables in the data to visual properties of the geom (**aesthetics**) like **size**, **color**, and **x** and **y** locations.\n\nComplete the template below to build a graph.\n\n```         \nggplot(data = <Data>) +\n  <Geom_Function>(mapping = aes(<Mappings>),\n  stat = <Stat>,\n  position = <Position>) +\n  <Coordinate_Function> +\n  <Facet_Function> +\n  <Scale_Function> +\n  <Theme_Function>\n```\n\nData, a Geom Function, and Aes Mappings are required.\nStat, Position, and the Coordinate, Facet, Scale, and Theme functions are not required and will supply sensible defaults.\n\n-   `ggplot(data = mpg, aes(x = cty, y = hwy))`: Begins a plot that you finish by adding layers to.\n    Add one geom function per layer.\n\n-   `last_plot()`: Returns the last plot.\n\n-   `ggsave(\"plot.png\", width = 5, height = 5)`: Saves last plot as 5' x 5' file named \"plot.png\" in working directory.\n    Matches file type to file extension.\n\n## Aes\n\nCommon aesthetic values.\n\n-   `color` and `fill`: String (`\"red\"`, `\"#RRGGBB\"`).\n\n-   `linetype`: Integer or string (0 = `\"blank\"`, 1 = `\"solid\"`, 2 = `\"dashed\"`, 3 = `\"dotted\"`, 4 = `\"dotdash\"`, 5 = `\"longdash\"`, 6 = `\"twodash\"`).\n\n-   `size`: Integer (in mm for size of points and text).\n\n-   `linewidth`: Integer (in mm for widths of lines).\n\n-   `shape`: Integer/shape name or a single character (`\"a\"`).\n\n    -   `shape` integer/name pairs: 0 = `\"square open\"`, 1 = `\"circle open\"`, 2 = `\"triangle open\"`, 3 = `\"plus\"`, 4 = `\"cross\"`, 5 = `\"diamond open\"`, 6 = `\"triangle down open\"`, 7 = `\"square cross\"`, 8 = `\"asterisk\"`, 9 = `\"diamond plus\"`, 10 = `\"circle plus\"`, 11 = `\"star\"`, 12 = `\"square plus\"`, 13 = `\"circle cross\"`, 14 = `\"square triangle\"`, 15 = `\"square\"`, 16 = `\"circle\"`, 17 = `\"triangle\"`, 18 = `\"diamond\"`, 19 = `\"circle small\"`, 20 = `\"bullet\"`, 21 = `\"circle filled\"`, 22 = `\"square filled\"`, 23 = `\"diamond filled\"`, 24 = `\"triangle filled\"`, 25 = `\"triangle down filled\"`\n\n## Geoms\n\nUse a geom function to represent data points, use the geom's aesthetic properties to represent variables.\nEach function returns a layer.\n\n### Graphical Primitives\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- ggplot(economics, aes(date, unemploy))\n\nb <- ggplot(seals, aes(x = long, y = lat))\n```\n:::\n\n\n\n\n-   `a + geom_blank()` and `a + expand_limits()`: Ensure limits include values across all plots.\n\n-   `b + geom_curve(aes(yend = lat + 1, xend = long + 1), curvature = 1)`: Draw a curved line from `(x, y)` to `(xend, yend)`.\n    `aes()` arguments: `x`, `xend`, `y`, `yend`, `alpha`, `angle`, `color`, `curvature`, `linetype`, `size`.\n\n-   `a + geom_path(lineend = \"butt\", linejoin = \"round\", linemitre = 1)`: Connect observations in the order they appear.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `group`, `linetype`, `size`.\n\n-   `a + geom_polygon(aes(alpha = 50))`: Connect points into polygons.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`, `subgroup`, `linetype`, `size`.\n\n-   `b + geom_rect(aes(xmin = long, ymin = lat, xmax = long + 1, ymax = lat + 1))`: Draw a rectangle by connecting four corners (`xmin`, `xmax`, `ymin`, `ymax`).\n    `aes()` arguments: `xmax`, `xmin`, `ymax`, `ymin`, `alpha`, `color`, `fill`, `linetype`, `size`.\n\n-   `a + geom_ribbon(aes(ymin = unemploy - 900, ymax = unemploy + 900)`: For each `x`, plot an interval from `ymin` to `ymax`.\n    `aes()` arguments: `x`, `ymax`, `ymin`, `alpha`, `color`, `fill`, `group`, `linetype`, `size`.\n\n#### Line Segments\n\nCommon aesthetics: `x`, `y`, `alpha`, `color`, `linetype`, `size`, `linewidth`.\n\n-   `b + geom_abline(aes(intercept = 0, slope = 1))`: Draw a diagonal reference line with a given `slope` and `intercept`.\n\n-   `b + geom_hline(aes(yintercept = lat))`: Draw a horizontal reference line with a given `yintercept`.\n\n-   `b + geom_vline(aes(xintercept = long))`: Draw a vertical reference line with a given `xintercept`.\n\n-   `b + geom_segment(aes(yend = lat + 1, xend = long + 1))`: Draw a straight line from `(x, y)` to `(xend, yend)`.\n\n-   `b + geom_spoke(aes(angle = 1:1155, radius = 1))`: Draw line segments using polar coordinates (`angle` and `radius`).\n\n### One Variable - Continuous\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc <- ggplot(mpg, aes(hwy))\nc2 <- ggplot(mpg)\n```\n:::\n\n\n\n\n-   `c + geom_area(stat = \"bin\")`: Draw an area plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linetype`, `linewidth`.\n\n-   `c + geom_density(kernel = \"gaussian\")`: Compute and draw kernel density estimates.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`, `linetype`, `linewidth`, `weight`.\n\n-   `c + geom_dotplot()`: Draw a dot plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`.\n\n-   `c + geom_freqpoly()`: Draw a frequency polygon.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `group`, `linetype`, `linewidth`.\n\n-   `c + geom_histogram(binwidth = 5)`: Draw a histogram.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linetype`, `linewidth`, `weight`.\n\n-   `c2 + geom_qq(aes(sample = hwy))`: Draw a quantile-quantile plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linetype`, `size`, `weight`.\n\n### One Variable - Discrete\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- ggplot(mpg, aes(fl))\n```\n:::\n\n\n\n\n-   `d + geom_bar()`: Draw a bar chart. `aes()` arguments: `x`, `alpha`, `color`, `fill`, `linetype`, `linewidth`, `weight`.\n\n### Two Variables - Both Continuous\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- ggplot(mpg, aes(cty, hwy))\n```\n:::\n\n\n\n\n-   `e + geom_label(aes(label = cty), nudge_x = 1, nudge_y = 1)`: Add text with a rectangle background.\n    `aes()` arguments: - `x`, `y`, `label`, `alpha`, `angle`, `color`, `family`, `fontface`, `hjust`, `lineheight`, `size`, `vjust`.\n\n-   `e + geom_point()`: Draw a scatter plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `shape`, `size`, `stroke`.\n\n-   `e + geom_quantile()`: Fit and draw quantile regression for the plot data.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `group`, `linetype`, `linewidth`, `weight`.\n\n-   `e + geom_rug(sides = \"bl\")`: Draw a rug plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `linetype`, `linewidth`.\n\n-   `e + geom_smooth(method = lm)`: Plot smoothed conditional means.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`, `linetype`, `linewidth`, `weight`.\n\n-   `e + geom_text(aes(label = cty), nudge_x = 1, nudge_y = 1)`: Add text to a plot.\n    `aes()` arguments: `x`, `y`, `label`, `alpha`, `angle`, `color`, `family`, `fontface`, `hjust`, `lineheight`, `size`, `vjust`.\n\n### Two Variables - One Discrete, One Continuous\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- ggplot(mpg, aes(class, hwy))\n```\n:::\n\n\n\n\n-   `f + geom_col()`: Draw a bar plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`, `linetype`, `linewidth`.\n\n-   `f + geom_boxplot()`: Draw a box plot.\n    `aes()` arguments: `x`, `y`, `lower`, `middle`, `upper`, `ymax`, `ymin`, `alpha`, `color`, `fill`, `group`, `linetype`, `shape`, `linewidth`, `weight`.\n\n-   `f + geom_dotplot(binaxis =\"y\", stackdir = \"center\")`: Draw a dot plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`.\n\n-   `f + geom_violin(scale = \"area\")`: Draw a violin plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`, `linetype`, `linewidth`, `weight`.\n\n### Two Variables - Both Discrete\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- ggplot(diamonds, aes(cut, color))\n```\n:::\n\n\n\n\n-   `g + geom_count()`: Plot a count of points in an area to address over plotting.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `shape`, `size`, `stroke`.\n\n-   `e + geom_jitter(height = 2, width = 2)`: Jitter points in a plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `shape`, `size`.\n\n### Two Variables - Continuous Bivariate Distribution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- ggplot(diamonds, aes(carat, price))\n```\n:::\n\n\n\n\n-   `h + geom_bin2d(binwidth = c(0.25, 500))`: Draw a heatmap of 2D rectangular bin counts.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linetype`, `size`, `weight`.\n\n-   `h + geom_density_2d()`: Plot contours from 2D kernel density estimation.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `group`, `linetype`, `linewidth`.\n\n-   `h + geom_hex()`: Draw a heatmap of 2D hexagonal bin counts.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linewidth`.\n\n### Two Variables - Continuous Function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- ggplot(economics, aes(date, unemploy))\n```\n:::\n\n\n\n\n-   `i + geom_area()`: Draw an area plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linetype`, `linewidth`.\n\n-   `i + geom_line()`: Connect data points, ordered by the x axis variable.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `group`, `linetype`, `linewidth`.\n\n-   `i + geom_step(direction = \"hv\"`: Draw a stairstep plot. `aes()` arguments: `x`, `y`, `alpha`, `color`, `group`, `linetype`, `linewidth`.\n\n### Two Variables - Visualizing Error\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(grp = c(\"A\", \"B\"), fit = 4:5, se = 1:2)\nj <- ggplot(df, aes(grp, fit, ymin = fit - se, ymax = fit + se))\n```\n:::\n\n\n\n\n-   `j + geom_crossbar(fatten = 2)`: Draw a crossbar.\n    `aes()` arguments: `x`, `y`, `ymax`, `ymin`, `alpha`, `color`, `fill`, `group`, `linetype`, `linewidth`.\n\n-   `j + geom_errorbar()`: Draw an errorbar.\n    Also `geom_errorbarh()`.\n    `aes()` arguments: `x`, `ymax`, `ymin`, `alpha`, `color`, `group`, `linetype`, `linewidth`, `width`.\n\n-   `j + geom_linerange()`: Draw a line range.\n    `aes()` arguments: `x`, `ymin`, `ymax`, `alpha`, `color`, `group`, `linetype`, `linewidth`.\n\n-   `j + geom_pointrange()`: Draw a point range.\n    `aes()` arguments: `x`, `y`, `ymin`, `ymax`, `alpha`, `color`, `fill`, `group`, `linetype`, `shape`, `linewidth`.\n\n### Two Variables - Maps\n\nDraw the appropriate geometric object depending on the simple features present in the data.\n`aes()` arguments: `map_id`, `alpha`, `color`, `fill`, `linetype`, `linewidth`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc <- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"))\nggplot(nc) +\n  geom_sf(aes(fill = AREA))\n```\n:::\n\n\n\n\n### Three Variables\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseals$z <- with(seals, sqrt(delta_long^2 + delta_lat^2))\nl <- ggplot(seals, aes(long, lat))\n```\n:::\n\n\n\n\n-   `l + geom_contour(aes(z = z))`: Draw 2D contour plot.\n    `aes()` arguments: `x`, `y`, `z`, `alpha`, `color`, `group`, `linetype`, `linewidth`, `weight`.\n\n-   `l + geom_contour_filled(aes(fill = z))`: Draw 2D contour plot with the space between lines filled.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `group`, `linetype`, `linewidth`, `subgroup`.\n\n-   `l + geom_raster(aes(fill = z), hjust = 0.5, vjust = 0.5, interpolate = FALSE)`: Draw a raster plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `fill`.\n\n-   `l + geom_tile(aes(fill = z))`: Draw a tile plot.\n    `aes()` arguments: `x`, `y`, `alpha`, `color`, `fill`, `linetype`, `linewidth`, `width`.\n\n<!-- Page 2 -->\n\n## Stats\n\nAn alternative way to build a layer.\n\nA stat builds new variables to plot (e.g., count, prop).\n\nVisualize a stat by changing the default stat of a geom function, `geom_bar(stat = \"count\")`, or by using a stat function, `stat_count(geom = \"bar\")`, which calls a default geom to make a layer (equivalent to a geom function).\nUse `after_stat(name)` syntax to map the stat variable `name` to an aesthetic.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni + stat_density_2d(aes(fill = after_stat(level)), geom = \"polygon\")\n```\n:::\n\n\n\n\nIn this example, `\"polygon\"` is the geom to use, `stat_density_2d()` is the stat function, `aes()` contains the geom mappings, and `level` is the variable created by stat.\n\n-   `c + stat_bin(binwidth = 1, boundary = 10)`: `x`, `y` \\| `count`, `ncount`, `density`, `ndensity`\n\n-   `c + stat_count(width = 1)`: `x`, `y` \\| `count`, `density`\n\n-   `c + stat_density(adjust = 1, kernel = \"gaussian\")`: `x`, `y` \\| `count`, `density`, `scaled`\n\n-   `e + stat_bin_2d(bins = 30, drop = T)`: `x`, `y`, `fill` \\| `count`, `density`\n\n-   `e + stat_bin_hex(bins =30)`: `x`, `y`, `fill` \\| `count`, `density`\n\n-   `e + stat_density_2d(contour = TRUE, n = 100)`: `x`, `y`, `color`, `linewidth` \\| `level`\n\n-   `e + stat_ellipse(level = 0.95, segments = 51, type = \"t\")`\n\n-   `l + stat_contour(aes(z = z))`: `x`, `y`, `z`, `order` \\| `level`\n\n-   `l + stat_summary_hex(aes(z = z), bins = 30, fun = max)`: `x`, `y`, `z`, `fill` \\| `value`\n\n-   `l + stat_summary_2d(aes(z = z), bins = 30, fun = mean)`: `x`, `y`, `z`, `fill` \\| `value`\n\n-   `f + stat_boxplot(coef = 1.5)`: `x`, `y` \\| `lower`, `middle`, `upper`, `width`, `ymin`, `ymax`\n\n-   `f + stat_ydensity(kernel = \"gaussian\", scale = \"area\")`: `x`, `y` \\| `density`, `scaled`, `count`, `n`, `violinwidth`, `width`\n\n-   `e + stat_ecdf(n = 40)`: `x`, `y` \\| `x`, `y`\n\n-   `e + stat_quantile(quantiles = c(0.1, 0.9), formula = y ~ log(x), method = \"rq\")`: `x`, `y` \\| `quantile`\n\n-   `e + stat_smooth(method = \"lm\", formula = y ~ x, se = T, level = 0.95)`: `x`, `y` \\| `se`, `x`, `y`, `ymin`, `ymax`\n\n-   `ggplot() + xlim(-5, 5) + stat_function(fun = dnorm, n = 20, geom = \"point\")`: `x` \\| `x`, `y`\n\n-   `ggplot() + stat_qq(aes(sample = 1:100))`: `x`, `y`, `sample` \\| `sample`, `theoretical`\n\n-   `e + stat_sum()`: `x`, `y`, `size` \\| `n`, `prop`\n\n-   `e + stat_summary(fun.data = \"mean_cl_boot\")`\n\n-   `h + stat_summary_bin(fun = \"mean\", geom = \"bar\")`\n\n-   `e + stat_identity()`\n\n-   `e + stat_unique()`\n\n## Scales\n\nOverride defaults with **scales** package.\n\n**Scales** map data values to the visual values of an aesthetic.\nTo change a mapping, add a new scale.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- d + geom_bar(aes(fill = fl))\n\nn + scale_fill_manual(\n  values = c(\"skyblue\", \"royalblue\", \"blue\", \"navy\"),\n  limits = c(\"d\", \"e\", \"p\", \"r\"),\n  breaks =c(\"d\", \"e\", \"p\", \"r\"),\n  name = \"fuel\", \n  labels = c(\"D\", \"E\", \"P\", \"R\")\n)\n```\n:::\n\n\n\n\nIn this example, `scale_` specifies a scale function, `fill` is the aesthetic to adjust, and `manual` is the prepackaged scale to use.\n\n`values` contains scale-specific arguments, `limits` specifies the range of values to include in mappings, `breaks` specifies the breaks to use in legend/axis, and `name` and `labels` specify the title and labels to use in the legend/axis.\n\n### General Purpose Scales\n\nUse with most aesthetics.\n\n-   `scale_*_continuous()`: Map continuous values to visual ones.\n\n-   `scale_*_discrete()`: Map discrete values to visual ones.\n\n-   `scale_*_binned()`: Map continuous values to discrete bins.\n\n-   `scale_*_identity()`: Use data values as visual ones.\n\n-   `scale_*_manual(values = c())`: Map discrete values to manually chosen visual ones.\n\n-   `scale_*_date(date_labels = \"%m/%d\", date_breaks = \"2 weeks\")`: Treat data values as dates.\n\n-   `scale_*_datetime()`: Treat data values as date times.\n    Same as `scale_*_date()`.\n    See `?strptime` for label formats.\n\n### X & Y Location Scales\n\nUse with x or y aesthetics (x shown here).\n\n-   `scale_x_log10()`: Plot `x` on log10 scale.\n\n-   `scale_x_reverse()`: Reverse the direction of the x axis.\n\n-   `scale_x_sqrt()`: Plot `x` on square root scale.\n\n### Color and Fill Scales (Discrete)\n\n-   `n + scale_fill_brewer(palette = \"Blues\")`: Use color scales from ColorBrewer.\n    For palette choices `RColorBrewer::display.brewer.all()`.\n\n-   `n + scale_fill_grey(start = 0.2, end = 0.8, na.value = \"red\")`: Use a grey gradient color scale.\n\n### Color and Fill Scales (Continuous)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\no <- c + geom_dotplot(aes(fill = ..x..))\n```\n:::\n\n\n\n\n-   `o + scale_fill_distiller(palette = \"Blues\")`: Interpolate a palette into a continuous scale.\n\n-   `o + scale_fill_gradient(low = \"red\", high = \"yellow\")`: Create a two color gradient.\n\n-   `o + scale_fill_gradient2(low = \"red\", high = \"blue\", mid = \"white\", midpoint = 25)`: Create a diverging color gradient.\n\n-   `o + scale_fill_gradientn(colors = topo.colors(6))`: Create a n-color gradient.\n    Also `rainbow()`, `heat.colors()`, `terrain.colors()`, `cm.colors()`, `RColorBrewer::brewer.pal()`.\n\n### Shape and Size Scales\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- e + geom_point(aes(shape = fl, size = cyl))\n```\n:::\n\n\n\n\n-   `p + scale_shape() + scale_size()`: Map discrete values to shape and size aesthetics.\n\n-   `p + scale_shape_manual(values = c(3:7))`: Map discrete values to specified shape values.\n\n-   `p + scale_radius(range = c(1,6))`: Map values to a shape's radius.\n\n-   `p + scale_size_area(max_size = 6)`: Like `scale_size()` but maps zero values to zero size.\n\nShapes used here are the same as the ones listed in the Aes section.\n\n## Coordinate Systems\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- d + geom_bar()\n```\n:::\n\n\n\n\n-   `u + coord_cartesian(xlim = c(0, 5))`: `xlim`, `ylim`.\n    The default Cartesian coordinate system.\n\n-   `u + coord_fixed(ratio = 1/2)`: `ratio`, `xlim`, `ylim`.\n    Cartesian coordinates with fixed aspect ration between x and y units.\n\n-   `ggplot(mpg, aes(y = fl)) + geom_bar()`: Flip Cartesian coordinates by switching x and y aesthetic mappings.\n\n-   `u + coord_polar(theta = \"x\", direction = 1)`: `theta`, `start`, `direction`.\n    Polar coordinates.\n\n-   `u + coord_trans(y = \"sqrt\")`: `x`, `y`, `xlim`, `ylim`.\n    Transformed Cartesian coordinates.\n    Set `xtrans` and `ytrans` to the name of a window function.\n\n-   `π + coord_sf()`: `xlim`, `ylim`, `crs`.\n    Ensures all layers use a common Coordinate Reference System.\n\n## Position Adjustments\n\nPosition adjustments determine how to arrange geoms that would otherwise occupy the same space.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- ggplot(mpg, aes(fl, fill = drv))\n```\n:::\n\n\n\n\n-   `s + geom_bar(position = \"dodge\")`: Arrange elements side by side.\n\n-   `s + geom_bar(position = \"fill\")`: Stack elements on top of one another, normalize height.\n\n-   `e + geom_point(position = \"jitter\")`: Add random noise to X and Y position of each element to avoid over plotting.\n\n-   `e + geom_label(position = \"nudge\")`: Nudge labels away from points.\n\n-   `s + geom_bar(position = \"stack\")`: Stack elements on top of one another.\n\nEach position adjustment can be recast as a function with manual `width` and `height` arguments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns + geom_bar(position = position_dodge(width = 1))\n```\n:::\n\n\n\n\n## Themes\n\n-   `u + theme_bw()`: White background with grid lines.\n\n-   `u + theme_gray()`: Grey background with white grid lines (default theme).\n\n-   `u + theme_dark()`: Dark grey background and grid lines for contrast.\n\n-   `u + theme_classic()`: No grid lines.\n\n-   `u + theme_light()`: Light grey axes and grid lines.\n\n-   `u + theme_linedraw()`: Uses only black lines.\n\n-   `u + theme_minimal()`: Minimal theme.\n\n-   `u + theme_void()`: Empty theme.\n\n-   `u + theme()`: Customize aspects of the theme such as axis, legend, panel, and facet properties.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu + labs(title = \"Title\") + theme(plot.title.position = \"plot\")\n```\n\n```{.r .cell-code}\nu + theme(panel.background = element_rect(fill = \"blue\"))\n```\n:::\n\n\n\n\n## Faceting\n\nFacets divide a plot into subplots based on the values of one or more discrete variables.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt <- ggplot(mpg, aes(cty, hwy)) + geom_point()\n```\n:::\n\n\n\n\n-   `t + facet_grid(. ~ fl)`: Facet into a column based on fl.\n\n-   `t + facet_grid(year ~ .)`: Facet into rows based on year.\n\n-   `t + facet_grid(year ~ fl)`: Facet into both rows and columns.\n\n-   `t + facet_wrap(~ fl)`: Wrap facets into a rectangular layout.\n\n-   `t + facet_grid(drv ~ fl, scales = \"free\")`: Set **scales** to let axis limits vary across facets.\n    Also `\"free_x\"` for x axis limits adjust to individual facets and `\"free_y\"` for y axis limits adjust to individual facets.\n\nSet **labeller** to adjust facet label:\n\n-   `t + facet_grid(. ~ fl, labeller = label_both)`: Labels each facet as \"fl: c\", \"fl: d\", etc.\n\n-   `t + facet_grid(fl ~ ., labeller = label_bquote(alpha ^ .(fl)))`: Labels each facet as \"𝛼^c^\", \"𝛼^d^\", etc.\n\n## Labels and Legends\n\nUse `labs()` to label elements of your plot.\n\n```         \nt + labs(x = \"New x axis label\", \n  y = \"New y axis label\",\n  title =\"Add a title above the plot\",\n  subtitle = \"Add a subtitle below title\",\n  caption = \"Add a caption below plot\",\n  alt = \"Add alt text to the plot\",\n  <Aes> = \"New <Aes> legend title\")\n```\n\n-   `t + annotate(geom = \"text\", x = 8, y = 9, label = \"A\")`: Places a geom with manually selected aesthetics.\n\n-   `p + guides(x = guide_axis(n.dodge = 2))`: Avoid crowded or overlapping labels with `guide_axis(n.dodge or angle)`.\n\n-   `n + guides(fill = \"none\")`: Set legend type for each aesthetic: `colorbar`, `legend`, or `none` (no legend).\n\n-   `n + theme(legend.position = \"bottom\")`: Place legend at \"bottom\", \"top\", \"left\", or \"right\".\n\n-   `n + scale_fill_discrete(name = \"Title\", labels = c(\"A\", \"B\", \"C\", \"D\", \"E\"))`: Set legend title and labels with a scale function.\n\n## Zooming\n\n-   `t + coord_cartesian(xlim = c(0, 100), ylim = c(10,20))`: Zoom without clipping (preferred).\n\n-   `t + xlim(0, 100) + ylim(10, 20)` or `t + scale_x_continuous(limits = c(0, 100)) + scale_y_continuous(limits = c(0, 100))`: Zoom with clipping (removes unseen data points).\n\n------------------------------------------------------------------------\n\nCC BY SA Posit Software, PBC • [info\\@posit.co](mailto:info@posit.co) • [posit.co](https://posit.co)\n\nLearn more at [ggplot2.tidyverse.org](https://ggplot2.tidyverse.org).\n\nUpdated: 2024-05.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"ggplot2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '3.5.1'\n```\n\n\n:::\n:::\n\n\n\n\n------------------------------------------------------------------------\n",
    "supporting": [
      "data-visualization_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}