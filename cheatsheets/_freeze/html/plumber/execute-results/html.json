{
  "hash": "b113bed0fae46c64e28bcc340ef78869",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"REST APIs with plumber :: Cheatsheet\"\ndescription: \" \"\nimage-alt: \"\"\nexecute:\n  eval: true\n  output: false\n  warning: false\n---\n\n::: {.cell .column-margin}\n<img src=\"images/logo-plumber.png\" height=\"138\" alt=\"Hex logo for plumber - the word 'plumber' written in green, where the letters are depicted as water pipes, which connect to the border of the logo. The background is a series of criss-crossing pipes in shades of black and grey.\" />\n<br><br><a href=\"../plumber.pdf\">\n<p><i class=\"bi bi-file-pdf\"></i> Download PDF</p>\n<img src=\"../pngs/plumber.png\" width=\"200\" alt=\"\"/>\n</a>\n<br><br>\n:::\n\n\n\n## Introduction to REST APIs\n\nWeb APIs use **HTTP** to communcation between **client** and **server**.\n\n### HTTP\n\nHTTP is built around a **request** and a **response**.\nA **client** makes a request to a **server**, which handles the request and provides a response.\nRequests and responses are specially formatted text containing details and data about the exchange between client and server.\n\n### Request\n\n`GET / get HTTP/1.1` -\\> HTTP Method, Path, HTTP Version\n\n`Host:`, `User-Agent:`, `Accept:` -\\> Headers\n\n`Request Body` -\\> Message body\n\n```         \ncurl -v \"http://httpbin.org/get\"\n\n#> GET / get HTTP/1.1\n#> Host: httpbin.org\n#> User-Agent: curl/7.55.1\n#> Accept: */*\n#\n# Request Body\n```\n\n### Response\n\n`HTTP/1.1 200 OK` -\\> HTTP Version, Status code, Reason phrase\n\n`Connection:`, `Date:` -\\> Headers\n\n`Response Body` -\\> Message body\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#< HTTP/1.1 200 OK\n#< Connection: keep-alive\n#< Date: Thu, 02 Aug 2018 18:22:22 GMT\n#\n# Response Body\n```\n:::\n\n\n\n## Plumber: Build APIs with R\n\nPlumber uses special comments to turn any arbitrary R code into API endpoints.\nThe example below defines a function that takes the `msg` argument and returns it embedded in additional text.\n\nPlumber comments begin with `#*` and `@` decoators define API characteristics.\nIn HTTP methods such as `@get` the `/<path>` defines the location of the endpoint.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n#* @apiTitle Plumber Example API\n\n#* Echo back the input\n#* @param msg The message to echo\n#* @get /echo\nfunction(msg = \"\") {\n  list(\n    msg = paste0(\"The message is: '\", msg, \"'\")\n  )\n}\n```\n:::\n\n\n\n## Plumber piperline\n\nPlumber endpoints contain R code that is executed in response to an HTTP request.\nIncoming requests pass through a set of mechanisms before a response is returned to the client.\n\n-   Filters: Filters can forward requests (after potentially mutating them), throw errors, or return a response without forwarding the request.\n    Filters are defined similarly to endpoints using the `@filter [name]` tag.\n    By default, filters apply to all endpoints.\n    Endpoints can opt out of filters using the `@preempt` tag.\n\n-   Parsers: Parsers determine how Plumber parses the incoming request body.\n    By default Plumber parses the request body as JavaScript Object Notation (JSON).\n    Other parsers, including custom parsers, are identified using the `@parser [parser name]` tag.\n    All registered parsers can be viewed with `registered_parsers()`.\n\n-   Endpoint: Endpoints define the R code that is executed in response to incoming requests.\n    These endpoints correspond to HTTP methods and respond to incoming requests that match the defined method.\n\n    -   Methods\n\n        -   `@get` - request a resource\n        -   `@post` - send data in body\n        -   `@put` - store/update data\n        -   `@delete` - delete resource\n        -   `@head` - no request body\n        -   `@options` - describe options\n        -   `@patch` - partial changes\n        -   `@use` - use all methods\n\n-   Serializer: Serializers determine how Plumber returns results to the client.\n    By default Plumber serializes the R object returned into JavaScript Object Notation (JSON).\n    Other serializers, including custom serializers, are identified using the `@serializer [serializer name]` tag.\n    All registered serializers can be viewed with `registered_serializers()`.\n\nIdentify as filter with `@filter`, filter name is `log`, and forward request with `forward()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n#* @filter log\nfunction(req, res) {\n  print(req$HTTP_USER_AGENT)\n  forward()\n}\n```\n:::\n\n\n\nDefine the endpoint description, opt out of the log filter, define the parser, HTTP method and endpoint path, and serializer:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#* Convert request body to uppercase\n#* @prempt log\n#* @parser json\n#* @post /uppercase\n#* @serializer json\nfunction(req, res) {\n  toupper(req$body)\n}\n```\n:::\n\n\n\n## Running Plumber APIs\n\nPlumber APIs can be run programmatically from within an R session.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n# Path to API definition\nplumb(\"plumber.R\") |>\n  pr_run(port = 5762) # Specify API port\n```\n:::\n\n\n\nThis runs the API on the host machine supported by the current R session.\n\n### IDE Integration\n\n![](images/plumber-ide.png){fig-align=\"center\"}\n\n::: {.callout-note appearance=\"minimal\" icon=\"false\" collapse=\"true\"}\n## Expand to read about plumber features in the RStudio IDE {aria-hidden=\"true\"}\n\n### plumber features in the RStudio IDE\n\n-   Create new Plumber API\n-   Publish API to RStudio Connect\n-   Run API in current R session\n:::\n\n## Documentation\n\nPlumber APIs automatically generate an OpenAPI specification file.\nThis specification file can be interpreted to generate a dynamic user-interface for the API.\nThe default interface is generated via Swagger\n\n![](images/plumber-documentation.png){fig-align=\"center\"}\n\n::: {.callout-note appearance=\"minimal\" icon=\"false\" collapse=\"true\"}\n## Expand to read about the Swagger user interface\n\n### Features in the Swagger user interface\n\n-   Endpoint details\n-   Parameter details\n-   Edit parameters\n-   Send request\n-   curl command used to send request\n:::\n\n## Interact with the API\n\nOnce the API is running, it can be interacted with using any HTTP client.\nNote that using `httr` requires using a separate R session from the one serving the API.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(resp <- httr::GET(\"localhost:5762/echo?msg=Hello\")) \n#> Response [http://localhost:5762/echo?msg=Hello] \n#> #> Date: 2018-08-07 20:06\n#> Status: 200\n#> Content-Type: application/json\n#> Size: 35 B\nhttr::content(resp, as = \"text\")\n#> [1] \"{\\\"msg\\\":[\\\"The message is: 'Hello'\\\"]}\"\n```\n:::\n\n\n\n<!-- Page 2 -->\n\n## Programmatic Plumber\n\n### Tidy Plumber\n\nPlumber is exceptionally customizable.\nIn addition to using special comments to create APIs, APIs can be created entirely programatically.\nThis exposes additional features and functionality.\nPlumber has a convenient \"tidy\" interface that allows API routers to be built piece by piece.\nThe following example is part of a standard `plumber.R` file.\n\nUse the `@plumber` tag, create a function that accepts and modifies a plumber router (`pr`), and use \"tidy functions\" like `pr_get()` and `pr_post()` for buildings out Plumber API.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n#* @plumber\nfunction(pr) {\n  pr |>\n    pr_get(path = \"/echo\",\n           handler = function(msg = \"\") {\n             list(msg = paste0(\n               \"The message is: '\",\n               msg,\n               \"'\")\n             )\n           }) |>\n    pr_get(path = \"/plot\",\n           handler = function() {\n             rand <- rnorm(100)\n             hist(rand)\n           },\n           serializer = serializer_png()) |>\n    pr_post(path = \"/sum\",\n            handler = function(a, b) {\n              as.numeric(a) + as.numeric(b)\n            })\n}\n```\n:::\n\n\n\n### OpenAPI\n\nPlumber automatically creates an OpenAPI specification file based on Plumber componenets.\nThis file can be further modified using `pr_set_api_spec()` with either a function that modifies the existing specification or a path to a `.yaml` or `.json` specification file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n#* @param msg The message to echo\n#* @get /echo\nfunction(msg = \"\") {\n  list(\n    msg = paste0(\"The messahe is: '\", msg, \"'\")\n  )\n}\n\n#* @plumber\nfunction(pr) {\n  pr |>\n    pr_set_api_spec(\n      function(spec) {\n        spec$paths[[\"echo\"]]$get$summary <- \"Echo back the input\"\n        spec # Return the updated specification\n      }\n    )\n}\n```\n:::\n\n\n\nBy default, Swagger is used to interpret the OpenAPI specification file and generate the user interface for the API.\nOther interpreters can be used to adjust the look and feel of the user interface via `pr_set_docs()`.\n\n## Advanced Plumber\n\n### Request and Response\n\nPlumber provides access to special `req` and `res` objects that can be passed to Plumber functions.\nThese objects provide access to the request submitted by the client and the response that will be sent to the client.\nEach object has several components, the most helpful of which are outlined below:\n\n**Request Objects**\n\n| Name                 | Example              | Description                                   |\n|-------------------|-------------------|----------------------------------|\n| `req$pr`             | `plumber::pr()`      | The Plumber router processing the request     |\n| `req$body`           | `list(a = 1)`        | Typically the same as `argsBody`              |\n| `req$argsBody`       | `list(a = 1)`        | The parsed body output                        |\n| `req$argsPath`       | `list(c = 3)`        | The values of the path arguments              |\n| `req$argsQuery`      | `list(e = 5)`        | The parsed output from `req$QUERY_STRING`     |\n| `req$cookies`        | `list(cook = \"a\")`   | A list of cookies                             |\n| `req$REQUEST_METHOD` | `\"GET\"`              | The method used for the HTTP request          |\n| `req$PATH_INFO`      | `\"/\"`                | The path of the incoming HTTP request         |\n| `req$HTTP_*`         | `\"HTTP_USER_AGENT\"`  | All of the HTTP headers sent with the request |\n| `req$bodyRaw`        | `charToRaw(\"a = 1\")` | The `raw()` contents of the request body      |\n\n: Table of request object names, examples, and descriptions\n\n**Response Objects**\n\n| Name                 | Example                   | Description                               |\n|-------------------|----------------------|-------------------------------|\n| `res$headers`        | `list(header = \"abc\")`    | HTTP headers to include in the response   |\n| `res$setHeader()`    | `setHeader(\"foo\", \"bar\")` | Sets an HTTP header                       |\n| `res$setCookie()`    | `setCookie(\"foo\", \"bar\")` | Sets an HTTP cookie on the client         |\n| `res$removeCookie()` | `removeCookie(\"foo\")`     | Removes an HTTP cooki4                    |\n| `res$body`           | `\"{\\\"a\\\":[1]}\"`           | Serialized output                         |\n| `res$status`         | `200`                     | The response HTTP status code             |\n| `res$toResponse()`   | `toResponse()`            | A list of `status`, `headers`, and `body` |\n\n: Table of response object names, examples, and descriptions\n\n### Async Plumber\n\nPlumber supports asynchronous execution via the **future** R package.\nThis pattern allows Plumber to concurrently process multiple requests.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n# Set the execution plan\nfuture::plan(\"multisession\")\n\n#* @get /slow\nfunction() {\n  promises::future_promise({\n    slow_calc() # Slow calculation\n  })\n}\n```\n:::\n\n\n\n### Mounting Routers\n\nPlumber routers can be combined by mounting routers into other routers.\nThis can be beneficial when building routers that involve several different endpoints and you want to break each component out into a separate router.\nThese separate routers can even be separate files loaded using `plumb()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\n# Create an initial router\nroute <- pr() |>\n  pr_get(\"/foo\", function() \"foo\")\n\n#* @plumber\nfunction(pr) {\n  pr |>\n    pr_mount(\"/bar\", route)\n}\n```\n:::\n\n\n\nIn the above example, the final route is `/bar/foo`.\n\n### Running Examples\n\nSome packages, like the Plumber package itself, may include example Plumber APIs.\nAvailable APIs can be viewed using `available_apis()`.\nThese example APIs can be run with `plumb_api()` combined with `pr_run()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\n\nplumb_api(package = \"plumber\", # package name\n          name = \"01-append\", # API name\n          edit = TRUE) |> # optionally open the file for editing\n  pr_run() # run the example API\n```\n:::\n\n\n\n## Deploying Plumber APIs\n\nOnce Plumber APIs have been developed, they often need to be deployed somewhere to be useful.\nPlumber APIs can be deployed in a variety of different ways.\nOne of the easiest way to deploy Plumber APIs is using Posit Connect, which supports push button publishing from the RStudio IDE.\n\n------------------------------------------------------------------------\n\nCC BY SA Posit Software, PBC • [info\\@posit.co](mailto:info@posit.co) • [posit.co](https://posit.co)\n\nLearn more at [rplumber.io](https://www.rplumber.io/).\n\nUpdated: 2024-05.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackageVersion(\"plumber\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] '1.2.2'\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}